epoch: 13, dev accu: 0.9656140350877193
ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) means that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( globally [73,244] ( prop_2 and prop_3 ) or prop_1 )
gold: For every moment in the next 73 to 244 time units either ( prop_2 ) and ( prop_3 ) should be detected or else ( prop_1 ) should be detected .
pred ltl: ( globally [73,244] ( prop_2 and prop_3 ) or prop_1 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( globally [338,564] ( prop_1 and prop_2 ) or prop_3 )
gold: For each time instant in the coming 338 to 564 time units ( prop_1 ) and ( prop_2 ) should be detected , or else ( prop_3 ) .
pred ltl: ( globally [348,564] ( prop_1 and prop_2 ) or prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at some time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or negation prop_2 )
gold: at some time ( prop_1 ) or do not ( prop_2 )
pred ltl: finally ( prop_1 or negation prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 and negation prop_2 )
gold: always ( prop_1 ) and don't ( prop_2 )
pred ltl: globally ( prop_1 and negation prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) can infer that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: It is always the case that in case that the scenario that ( prop_1 ) is detected , and ( prop_2 ) , then the following condition holds : simultaneously ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: Globally , when the transition action that ( prop_1 ) occurs then all of the following conditions are true : ( prop_2 ) , or promptly ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( ( ( prop_4 until [155,563] prop_3 ) and prop_2 ) imply prop_1 )
gold: If ( prop_4 ) happens and continues to happen until at some point during the 155 to 563 time units ( prop_3 ) is detected , and also ( prop_2 ) , then ( prop_1 ) .
pred ltl: ( ( ( prop_4 until [155,563] prop_3 ) and prop_2 ) imply prop_1 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: negation ( prop_1 and prop_2 )
gold: do not ( prop_1 ) and ( prop_2 )
pred ltl: negation ( prop_1 and prop_2 )

ltl: ( finally [421,534] ( prop_1 or prop_3 ) imply prop_2 )
gold: It is required that at some moment during the coming 421 to 534 time units , either ( prop_1 ) or ( prop_3 ) should be detected , and as a response ( prop_2 ) .
pred ltl: ( finally [421,534] ( prop_1 or prop_3 ) imply prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: On condition that ( prop_1 ) , then in response at the same time instant ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_2 or prop_3 )
gold: when possible ( prop_1 ) ( prop_2 ) or ( prop_3 )
pred ltl: finally ( prop_2 or prop_3 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: In case the scenario ( prop_1 ) is detected and the transition action ( prop_2 ) is observed, then ( prop_3 ) .. ( prop_n ) should not take place.
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that in case that ( prop_1 ) then in response instantly ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( negation prop_1 imply prop_2 )
gold: don't ( prop_1 ) means that ( prop_2 )
pred ltl: ( negation prop_1 imply prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: whenever ( prop_1 ) can infer that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: whenever ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if whenever ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 or globally ( finally prop_2 ) )
gold: ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or globally ( finally prop_2 ) )
gold: ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: ( prop_1 or globally ( finally prop_2 ) )

ltl: ( prop_1 imply finally prop_2 )
gold: when ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( ( negation prop_2 and prop_1 ) or prop_3 )
gold: If ( prop_2 ) is not detected and ( prop_1 ) is detected, or ( prop_3 ) is detected .
pred ltl: ( ( negation prop_2 and prop_1 ) or prop_3 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: negation ( ( prop_3 until [246,530] prop_2 ) or prop_1 )
gold: It is not the case that at some point ( prop_3 ) happens and continues to happen until at some other point during the 246 to 530 time units ( prop_2 ) is detected , or else ( prop_1 ) .
pred ltl: ( negation ( prop_3 until [246,530] prop_2 ) or prop_1 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( finally prop_3 and prop_2 ) and prop_1 )
gold: It is required that at some time point in the future ( prop_3 ) should be detected , and ( prop_2 ) , and ( prop_1 ) .
pred ltl: ( finally ( prop_3 and prop_2 ) and prop_1 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , if the scenario that ( prop_1 ) occurs , then the following condition holds : immediately ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( finally prop_1 and prop_2 )
gold: repeatedly ( prop_1 ) and ( prop_2 )
pred ltl: globally ( finally prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply globally ( finally prop_2 ) )
gold: if whenever ( prop_1 ) , repeatedly ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [23,66] prop_3 )
gold: In case that ( prop_1 ) , or ( prop_2 ) then in response during the subsequent 23 to 66 time units , continuously ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [23,66] prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 or globally ( finally prop_2 ) )
gold: forever ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: globally ( prop_1 or globally ( finally prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )
gold: Globally , if ( prop_1 ) , and ( prop_2 ) then in response right away ( prop_3 ) and ( prop_4 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: ( ( ( prop_3 or prop_1 ) equal prop_2 ) until prop_4 )
gold: The scenario in which ( prop_3 ) or ( prop_1 ) is detected should be equivalent to the scenario in which ( prop_2 ) is detected , until ( prop_4 ) is detected .
pred ltl: ( ( ( prop_3 or prop_1 ) equal prop_2 ) until prop_4 )

ltl: finally ( prop_1 and globally prop_2 )
gold: whenever ( prop_1 ) and always ( prop_2 )
pred ltl: finally ( prop_1 and globally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [34,40] prop_3 )
gold: If either ( prop_1 ) or ( prop_2 ) happens, then ( prop_3 ) will happen and this scenario will continue for the next 34 to 40 time units.
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [34,40] prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until globally prop_2 )
gold: at some time ( prop_1 ) until forever ( prop_2 )
pred ltl: finally ( prop_1 until globally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: In the case the scenario that ( prop_1 ) takes place then all of the following conditions hold : at the same time ( prop_2 ) and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: During the interval that ( prop_1 ) or ( prop_2 ) then at the same time ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 until [19,21] prop_4 ) )
gold: Globally , if ( prop_1 ) , and ( prop_2 ) , then the following condition holds : ( prop_3 ) then this condition shall continue consecutively until there will be sometime during the subsequent 19 to 21 time units eventually , at which the event that ( prop_4 ) will take place .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 until [19,21] prop_4 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: On condition that the transition action that ( prop_1 ) happens , then all of the following conditions hold : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: negation ( prop_1 or finally prop_2 )
gold: don't ( prop_1 ) or whenever ( prop_2 )
pred ltl: negation ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , everytime when the event that ( prop_1 ) happens , then the following condition is true : promptly the scenario that ( prop_2 ) should not take place , and at the same time point the transition action that ( prop_3 ) will get observed .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: when ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: if at some time ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when when possible ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when possible ( prop_1 ) can infer that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: whenever ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: When the event that ( prop_1 ) gets detected then the following condition is true : at the same time point ( prop_2 ) , and simultaneously ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( negation ( prop_2 equal prop_3 ) or prop_1 )
gold: It is not the case that ( prop_2 ) is equivalent to ( prop_3 ), or ( prop_1 ) .
pred ltl: ( negation ( prop_2 equal prop_3 ) or prop_1 )

ltl: ( ( finally [125,222] prop_1 or prop_2 ) or prop_3 )
gold: There should be a moment during the interval from 125 to 222 time units in the future at which ( prop_1 ) is observed , or the scenario that ( prop_2 ) should occur , or else ( prop_3 ) should be detected .
pred ltl: ( ( finally [125,222] prop_1 or prop_2 ) or prop_3 )

ltl: ( finally prop_1 imply prop_2 )
gold: if when possible ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) can infer that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: The condition ( prop_2 ) always holds if ( prop_1 ) is the case.
pred ltl: ( prop_1 imply prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: ( ( prop_1 imply prop_2 ) and prop_3 )
gold: If ( prop_1 ) then ( prop_2 ) , and ( prop_3 ) .
pred ltl: ( ( prop_1 imply prop_2 ) and prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )
gold: Globally , while ( prop_1 ) , or ( prop_2 ) then all of the following conditions hold : the event that ( prop_3 ) ought to be detected promptly , and ( prop_4 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) means that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: The following condition always holds when ( prop_1 ) and ( prop_2 ): ( prop_3 ).
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: When the event that ( prop_1 ) happens then ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( ( ( prop_2 equal prop_3 ) until prop_4 ) imply prop_1 )
gold: If it is the case that ( prop_2 ) and ( prop_3 ) are equivalent , until ( prop_4 ) happens , then implies ( prop_1 ) .
pred ltl: ( ( ( prop_2 equal prop_3 ) until prop_4 ) imply prop_1 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( negation ( prop_1 and prop_2 ) until prop_3 )
gold: It is not the case that ( prop_1 ) and ( prop_2 ) happen at the same time , the above condition will hold until ( prop_3 ) happens .
pred ltl: ( negation ( prop_1 and prop_2 ) until prop_3 )

ltl: globally ( prop_1 and finally prop_2 )
gold: forever ( prop_1 ) and whenever ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or globally prop_2 )
gold: when possible ( prop_1 ) or always ( prop_2 )
pred ltl: finally ( prop_1 or globally prop_2 )

ltl: ( globally [171,529] ( prop_2 imply prop_1 ) or prop_3 )
gold: For each time instant in the next 171 to 529 time units ( prop_2 ) implies ( prop_1 ) , or else ( prop_3 ) .
pred ltl: ( globally [171,529] ( prop_2 imply prop_1 ) or prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_2 equal prop_3 ) until prop_1 ) imply prop_4 )
gold: If at some point ( prop_2 ) is equivalent to ( prop_3 ) and this scenario continues until ( prop_1 ) is detected , then ( prop_4 ) .
pred ltl: ( ( ( prop_2 equal prop_3 ) until prop_1 ) imply prop_4 )

ltl: ( globally prop_1 imply prop_2 )
gold: when always ( prop_1 ) , ( prop_2 )
pred ltl: ( globally prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that whenever ( prop_1 ) then the following condition is true : ( prop_2 ) , and at the same time ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: at some time ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: whenever ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when possible ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: It is always the case that in case that ( prop_1 ) and ( prop_2 ) , then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: If the scenario ( prop_1 ) is observed, then the following condition is true: ( prop_2 ) and ( prop_3 ).
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( negation ( globally [164,612] prop_3 ) or prop_1 ) imply prop_2 )
gold: If it is not the case that ( prop_3 ) is detected for each time instant in the coming 164 to 612 time units , or else ( prop_1 ) happens , then ( prop_2 ) .
pred ltl: ( ( negation prop_3 imply prop_1 ) or prop_2 )

ltl: negation ( finally ( prop_1 ) and finally prop_2 )
gold: don't ( prop_1 ) and at some time ( prop_2 )
pred ltl: negation ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: at any time ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that in case that ( prop_1 ) then the following condition is true : ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( negation ( prop_1 ) imply finally prop_2 )
gold: if do not ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( negation ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: whenever ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or globally prop_2 )
gold: when possible ( prop_1 ) or forever ( prop_2 )
pred ltl: finally ( prop_1 or globally prop_2 )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( finally prop_1 and prop_2 )
gold: repeatedly ( prop_1 ) and ( prop_2 )
pred ltl: globally ( finally prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: As soon as ( prop_1 ) , and ( prop_2 ) , then the following condition is true : ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) and globally prop_2 )
gold: never ( prop_1 ) and forever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and globally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at some time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: forever ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , during the interval that the event that ( prop_1 ) does not take place and ( prop_2 ) then all of the following conditions hold : immediately ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( globally ( negation prop_1 ) imply prop_2 )
gold: when never ( prop_1 ) , ( prop_2 )
pred ltl: ( globally ( negation prop_1 ) imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( finally ( prop_1 ) until finally prop_2 )
gold: repeatedly ( prop_1 ) until whenever ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) until finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: It is always the case that whenever ( prop_1 ) or ( prop_2 ) , then the following condition is true : simultaneously ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: whenever ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: When the transition action that ( prop_1 ) gets detected or ( prop_2 ) then the following condition is true : simultaneously ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 imply globally ( finally prop_2 ) )
gold: ( prop_1 ) means that repeatedly ( prop_2 )
pred ltl: ( prop_1 imply globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_1 and prop_2 ) imply prop_4 ) or prop_3 )
gold: If ( prop_1 ) and ( prop_2 ) are detected then implies ( prop_4 ) should happen ; or else if ( prop_3 ) is detected .
pred ltl: ( ( ( prop_1 and prop_2 ) imply prop_4 ) or prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 until globally ( negation prop_2 ) )
gold: ( prop_1 ) until never ( prop_2 )
pred ltl: ( prop_1 until globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that if the transition action that ( prop_1 ) gets observed , then the following condition is true : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: globally ( negation ( prop_1 ) until finally prop_2 )
gold: never ( prop_1 ) until when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( negation ( prop_1 until prop_3 ) and prop_2 )
gold: It is not the case that ( prop_1 ) is happening until ( prop_3 ) happens at some point in the future , and ( prop_2 ) .
pred ltl: ( negation ( prop_1 until prop_3 ) and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_4 imply prop_1 ) or prop_2 ) or prop_3 )
gold: If ( prop_4 ) then ( prop_1 ) happens , or else ( prop_2 ) or ( prop_3 ) .
pred ltl: ( ( ( prop_4 imply prop_1 ) or prop_2 ) or prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 until globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) until repeatedly ( prop_2 )
pred ltl: finally ( prop_1 until globally ( finally prop_2 ) )

ltl: finally ( prop_1 until globally ( negation prop_2 ) )
gold: whenever ( prop_1 ) until never ( prop_2 )
pred ltl: finally ( prop_1 until globally ( negation prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when at any time ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , when ( prop_1 ) , or ( prop_2 ) then the following condition holds : at the same time point ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: When the event ( prop_1 ) happens, then ( prop_2 ) and ( prop_3 ) will be observed.
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( prop_1 or globally prop_2 )
gold: forever ( prop_1 ) or forever ( prop_2 )
pred ltl: globally ( prop_1 or globally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when possible ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( globally ( negation prop_1 ) imply prop_2 )
gold: when never ( prop_1 ) , ( prop_2 )
pred ltl: ( globally ( negation prop_1 ) imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at some time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally prop_3 )
gold: If ( prop_1 ) and the event ( prop_2 ) are detected, then ( prop_3 ) will occur at some point in the future.
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: It is always the case that when ( prop_1 ) , or ( prop_2 ) , then all of the following conditions hold : instantly ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )
gold: Globally , everytime when ( prop_1 ) , and the scenario that ( prop_2 ) happens then promptly ( prop_3 ) , and promptly the transition action that ( prop_4 ) has to get detected .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when whenever ( prop_1 ) , when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , when ( prop_1 ) , or ( prop_2 ) then the following condition holds : immediately ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( ( negation prop_3 equal prop_1 ) or prop_2 )
gold: ( prop_3 ) does not happen is equivalent to ( prop_1 ) happens , or else ( prop_2 ) .
pred ltl: ( ( negation prop_3 equal prop_1 ) or prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [1,45] prop_2 ) )
gold: In case ( prop_1 ), ( prop_2 ) should exist within the first 1 to 45 time units, and ( prop_3 ) should be true during that time.
pred ltl: globally ( prop_1 imply ( prop_3 until [1,45] prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or always ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) means that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: negation ( prop_1 or negation prop_2 )
gold: don't ( prop_1 ) or do not ( prop_2 )
pred ltl: negation ( prop_1 or negation prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , whenever ( prop_1 ) or ( prop_2 ) , then the following condition holds : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that whenever the event that ( prop_1 ) gets detected then all of the following conditions are true : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( ( ( prop_4 or prop_2 ) imply prop_1 ) and prop_3 )
gold: The scenario that ( prop_1 ) should be detected whenever ( prop_4 ) or the event that ( prop_2 ) is observed , and at the same time ( prop_3 ) should be true .
pred ltl: ( ( ( prop_1 imply prop_4 ) or prop_2 ) and prop_3 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: ( ( negation prop_3 or prop_2 ) equal prop_1 )
gold: If it is not the case that ( prop_3 ) or ( prop_2 ) is true if and only if ( prop_1 ) is true .
pred ltl: ( negation ( prop_3 or prop_2 ) equal prop_1 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: It is always the case that in case that ( prop_1 ) , then all of the following conditions hold : ( prop_2 ) , or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: globally ( prop_1 and globally prop_2 )
gold: always ( prop_1 ) and always ( prop_2 )
pred ltl: globally ( prop_1 and globally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if when possible ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , everytime when the scenario that ( prop_1 ) takes place , then in response ( prop_2 ) , and the transition action that ( prop_3 ) shall simultaneously get observed .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 and globally ( finally prop_2 ) )
gold: ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: ( prop_1 and globally ( finally prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: It is always the case that whenever the transition action that ( prop_1 ) is detected then simultaneously ( prop_2 ) or at the same time the transition action that ( prop_3 ) will have to occur .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: ( ( ( prop_2 equal prop_4 ) imply prop_3 ) or prop_1 )
gold: ( prop_2 ) is equivalent to ( prop_4 ) will lead to ( prop_3 ) , or else ( prop_1 ) .
pred ltl: ( ( ( prop_2 equal prop_4 ) imply prop_3 ) or prop_1 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) or ( prop_2 ) then immediately ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 or prop_3 ) )
gold: Whenever the transition action that ( prop_1 ) gets detected , and ( prop_2 ) , then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )
gold: In the event that ( prop_1 ) and ( prop_2 ) happen, then the event ( prop_3 ) should be detected immediately and ( prop_4 ) should happen.
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: It is always the case that when the scenario that ( prop_1 ) occurs , then all of the following conditions are true : at the same time instant the scenario that ( prop_2 ) shall get observed or at the same moment ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: always ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when when possible ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( finally prop_1 or prop_2 )
gold: repeatedly ( prop_1 ) or ( prop_2 )
pred ltl: globally ( finally prop_1 or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when whenever ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) happens and the transition action ( prop_2 ) is detected, then ( prop_3 ) will happen.
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or negation ( finally prop_2 ) )
gold: whenever ( prop_1 ) or do not ( prop_2 )
pred ltl: finally ( prop_1 or negation ( finally prop_2 ) )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_4 equal prop_1 ) or prop_2 ) or prop_3 )
gold: If ( prop_4 ) is equivalent to ( prop_1 ) or else ( prop_2 ) or else ( prop_3 ) .
pred ltl: ( ( ( prop_4 equal prop_1 ) or prop_2 ) or prop_3 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: If ( prop_1 ) is true, then ( prop_2 ) and ( prop_3 ) are also true.
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( ( ( prop_3 imply prop_1 ) and prop_4 ) or prop_2 )
gold: If ( prop_3 ) then ( prop_1 ) , and also ( prop_4 ) , or else ( prop_2 ) .
pred ltl: ( ( ( prop_3 imply prop_1 ) and prop_4 ) or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: at any time ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when whenever ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: During the interval that ( prop_1 ) , or ( prop_2 ) then the following condition holds : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: If ( prop_1 ) happens, then ( prop_2 ) and ( prop_3 ) will happen at the same time.
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [27,30] ( finally [0,21] prop_3 ) )
gold: Everytime when the event that ( prop_1 ) is observed and ( prop_2 ) then all of the following conditions hold : for each time point in the first 27 to 30 time units , there will have to be sometime within the next 0 to 21 time units , at which ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [27,30] ( finally [0,21] prop_3 ) )

ltl: ( ( ( prop_3 imply prop_4 ) or prop_1 ) or prop_2 )
gold: In case that ( prop_3 ) then ( prop_4 ) , or else if ( prop_1 ) , or else if ( prop_2 ) .
pred ltl: ( ( ( prop_3 imply prop_4 ) imply prop_1 ) or prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [3,13] prop_2 ) )
gold: Globally , in case that the event that ( prop_1 ) is detected then at a certain moment within the coming 3 to 13 time units , ultimately the event that ( prop_2 ) needs to be observed , and till then ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_3 until [3,13] prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally prop_3 )
gold: It is always the case that while ( prop_1 ) , or ( prop_2 ) then all of the following conditions hold : continuously ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: when ( prop_1 ) , when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [19,95] ( finally prop_3 ) )
gold: If ( prop_1 ) and the event ( prop_2 ) are detected, then ( prop_3 ) will exist at some point within the next 19 to 95 time units.
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [19,95] ( finally prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that if the event that ( prop_1 ) takes place then the following condition is true : ( prop_2 ) , and at once ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: at any time ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 or negation prop_2 )
gold: forever ( prop_1 ) or do not ( prop_2 )
pred ltl: globally ( prop_1 or negation prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: always ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: globally ( negation prop_1 or prop_2 )
gold: never ( prop_1 ) or ( prop_2 )
pred ltl: globally ( negation prop_1 or prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: globally ( prop_1 imply ( prop_2 until prop_3 ) )
gold: It is always the case that whenever ( prop_1 ) , then all of the following conditions hold : ( prop_2 ) and has to consecutively hold like that until there will be eventually a certain time instant in the future before the end of the execution , at which the scenario that ( prop_3 ) will get observed .
pred ltl: globally ( prop_1 imply ( prop_2 until prop_3 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( globally [489,663] ( prop_1 imply prop_3 ) or prop_2 )
gold: It is required that for every moment during the interval 489 to 663 either the event that ( prop_1 ) is detected and in response ( prop_3 ) should happen , or ( prop_2 ) should be true .
pred ltl: ( globally [489,636] ( prop_1 and prop_3 ) or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [1,5] ( finally prop_3 ) )
gold: If ( prop_1 ) , and ( prop_2 ) , then all of the following conditions hold : for each time point in the subsequent 1 to 5 time units at a certain time point in the future before the execution ends eventually ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [1,5] ( finally prop_3 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: If ( prop_1 ) , then in response at the same time ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [26,45] prop_2 ) )
gold: In case that ( prop_1 ) , then the following condition is true : there should finally exist a certain time instant within the following 26 to 45 time units , at which ( prop_2 ) , before this continuously ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_3 until [26,45] prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( ( negation prop_2 imply prop_1 ) and prop_3 )
gold: If ( prop_2 ) does not happen , then ( prop_1 ) , and ( prop_3 ) .
pred ltl: ( ( negation prop_2 imply prop_1 ) and prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that if the event that ( prop_1 ) happens then the following condition holds : immediately ( prop_2 ) and at the same time ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )
gold: Whenever ( prop_1 ) or ( prop_2 ) then all of the following conditions hold : ( prop_3 ) and the event that ( prop_4 ) instantly takes place .
pred ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: globally ( negation ( prop_1 ) until finally prop_2 )
gold: never ( prop_1 ) until at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( negation ( prop_1 and prop_3 ) equal prop_2 )
gold: It is not the case that both ( prop_1 ) and ( prop_3 ) are detected at the same time if and only if ( prop_2 ) is detected .
pred ltl: ( negation ( prop_1 and prop_3 ) equal prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) , and ( prop_2 ) then the following condition holds : starting without any delay ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) means that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( globally ( negation ( prop_1 ) ) imply finally prop_2 )
gold: never ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( globally ( negation ( prop_1 ) ) imply finally prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) can infer that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: In the case ( prop_1 ) then all of the following conditions hold : starting without any delay ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) , and ( prop_2 ) then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply finally [33,93] ( globally prop_3 ) )
gold: There exists a certain moment during the next 33 to 93 time units, at which ( prop_3 ) happens, after which this scenario ought to continue in the future before the simulation ends.
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally [33,93] prop_3 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( ( finally ( negation prop_1 ) or prop_2 ) equal prop_3 )
gold: It is equivalent to have ( prop_3 ) if at the end of the simulation it is not the case that ( prop_1 ) is detected or ( prop_2 ) is detected .
pred ltl: ( ( negation prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: When the transition action that ( prop_1 ) happens then the following condition is true : simultaneously the event that ( prop_2 ) needs to be detected , or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at some time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: whenever ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( negation ( prop_3 equal prop_1 ) imply prop_2 )
gold: If it is not the case that ( prop_3 ) if and only if ( prop_1 ) then ( prop_2 ) .
pred ltl: ( negation ( prop_3 equal prop_1 ) imply prop_2 )

ltl: globally ( negation ( prop_1 ) or globally ( negation prop_2 ) )
gold: never ( prop_1 ) or never ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or globally ( negation prop_2 ) )

ltl: globally ( prop_1 until prop_2 )
gold: forever ( prop_1 ) until ( prop_2 )
pred ltl: globally ( prop_1 until prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( globally [494,741] ( negation prop_3 or prop_2 ) equal prop_1 )
gold: It is true that if at all the time point during the 494 to 741 time units , either ( prop_3 ) is not observed or ( prop_2 ) then this is equivalent to the scenario that ( prop_1 ) .
pred ltl: ( ( negation prop_3 or prop_2 ) equal prop_1 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: ( globally [412,427] ( prop_1 imply prop_3 ) equal prop_2 )
gold: For each moment in time during the next 412 to 427 time units , if the scenario that ( prop_1 ) is observed then in response ( prop_3 ) should also be observed at the same time instant , which is equivalent to saying that ( prop_2 ) .
pred ltl: ( globally [412,427] ( prop_1 imply prop_3 ) equal prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when at some time ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Whenever the event that ( prop_1 ) gets observed , then all of the following conditions are true : immediately ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: While ( prop_1 ) , or ( prop_2 ) then all of the following conditions are true : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [7,23] prop_3 )
gold: In case that the event that ( prop_1 ) is observed , and ( prop_2 ) , then the following condition is true : ( prop_3 ) then this condition lasts for each time instant during the next 7 to 23 time units .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [7,23] prop_3 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: ( negation ( prop_1 until [411,850] prop_3 ) imply prop_2 )
gold: If it is not the case that ( prop_1 ) happens and continues to happen until at some point during the 411 to 850 time units ( prop_3 ) is detected , then ( prop_2 ) .
pred ltl: ( negation ( prop_1 until [411,850] prop_3 ) imply prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: forever ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( globally prop_1 imply prop_2 )
gold: when forever ( prop_1 ) , ( prop_2 )
pred ltl: ( globally prop_1 imply prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( finally prop_1 and prop_2 )
gold: repeatedly ( prop_1 ) and ( prop_2 )
pred ltl: globally ( finally prop_1 and prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )
gold: never ( prop_1 ) and never ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply globally ( finally prop_2 ) )
gold: when ( prop_1 ) , repeatedly ( prop_2 )
pred ltl: ( prop_1 imply globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when possible ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( negation ( prop_1 ) or globally ( finally prop_2 ) )
gold: never ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or globally ( finally prop_2 ) )

ltl: ( prop_1 until globally ( finally prop_2 ) )
gold: ( prop_1 ) until repeatedly ( prop_2 )
pred ltl: ( prop_1 until globally ( finally prop_2 ) )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: negation ( prop_1 until finally prop_2 )
gold: don't ( prop_1 ) until at any time ( prop_2 )
pred ltl: negation ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [33,41] prop_3 )
gold: If ( prop_1 ) or ( prop_2 ) happens, then ( prop_3 ) will happen and last for 33 to 41 time units.
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [33,41] prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) means that whenever ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 until globally prop_2 )
gold: ( prop_1 ) until always ( prop_2 )
pred ltl: ( prop_1 until globally prop_2 )

ltl: ( ( ( prop_2 imply prop_3 ) and prop_1 ) imply prop_4 )
gold: If ( prop_2 ) then ( prop_3 ) , and ( prop_1 ) , then ( prop_4 ) .
pred ltl: ( ( ( prop_2 imply prop_3 ) and prop_1 ) imply prop_4 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at any time ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [10,20] ( finally [6,93] prop_3 ) )
gold: The transition action ( prop_3 ) will eventually be detected at the next 10 to 20 units within the next 6 to 93 time units, as long as either ( prop_1 ) or ( prop_2 ) is true.
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [10,20] ( finally [6,93] prop_3 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , everytime when the transition action that ( prop_1 ) happens , and the event that ( prop_2 ) is detected , then in response ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: When the scenario that ( prop_1 ) is observed , then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [31,57] prop_2 ) )
gold: In case that the scenario that ( prop_1 ) takes place , then all of the following conditions hold : at a time during the subsequent 31 to 57 time units the scenario that ( prop_2 ) , until then ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_3 until [31,57] prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: If either ( prop_1 ) or ( prop_2 ) is true, then ( prop_3 ) is also true.
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [13,67] ( finally [12,51] prop_3 ) )
gold: Whenever ( prop_1 ) , or ( prop_2 ) then all of the following conditions hold : for each moment during the next 13 to 67 time units , at a certain moment during the following 12 to 51 time units the event that ( prop_3 ) shall eventually occur .
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [13,67] ( finally [12,51] prop_3 ) )

ltl: ( finally prop_1 imply prop_2 )
gold: whenever ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: globally ( prop_1 or globally ( finally prop_2 ) )
gold: forever ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: globally ( prop_1 or globally ( finally prop_2 ) )

ltl: globally ( prop_1 and finally prop_2 )
gold: always ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 and globally ( finally prop_2 ) )
gold: ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: ( prop_1 and globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( prop_3 imply prop_2 ) and prop_1 )
gold: If ( prop_3 ) then ( prop_2 ) happens , and also ( prop_1 ) .
pred ltl: ( ( prop_3 imply prop_2 ) and prop_1 )

ltl: ( finally prop_1 imply prop_2 )
gold: when possible ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that everytime when the event that ( prop_1 ) gets detected , then all of the following conditions hold : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: when possible ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: globally ( ( prop_2 until [9,97] prop_1 ) imply globally prop_3 )
gold: It is always the case that when there will be a time in the next 9 to 97 time units ultimately , at which ( prop_1 ) , and until then ( prop_2 ) then all of the following conditions hold : in the future , ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) can infer that never ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )

ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )
gold: if at some time ( prop_1 ) , never ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply finally prop_3 )
gold: It is always the case that if ( prop_1 ) and ( prop_2 ) , then all of the following conditions are true : at a certain time point in the future , ( prop_3 ) will take place.
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally prop_3 )

ltl: finally ( prop_1 or negation prop_2 )
gold: whenever ( prop_1 ) or do not ( prop_2 )
pred ltl: finally ( prop_1 or negation ( finally prop_2 ) )

ltl: globally ( negation ( prop_1 ) until finally prop_2 )
gold: never ( prop_1 ) until whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) until finally prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) means that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) , or ( prop_2 ) , then the following condition is true : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: at some time ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: If ( prop_1 ) or ( prop_2 ) then the following condition is true : in no time ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 equal prop_3 ) equal prop_2 )
gold: It is required that the scenario in which ( prop_1 ) is equivalent to ( prop_3 ) to be observed at some point in the future if and only if ( prop_2 ) is true .
pred ltl: ( finally ( prop_1 equal prop_3 ) equal prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )
gold: While ( prop_1 ) and ( prop_2 ) then in response there will be a certain time instant in the future before the execution ends finally , after which ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) or ( prop_2 ) then the following condition is true : promptly ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply globally [21,30] ( finally prop_2 ) )
gold: In case that ( prop_1 ) , then the following condition holds : for each time instant during the coming 21 to 30 time units there needs to be a certain time point in the future before the end of the simulation , at which the transition action that ( prop_2 ) shall occur eventually .
pred ltl: globally ( prop_1 imply globally [21,30] ( finally prop_2 ) )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 until globally prop_2 )
gold: whenever ( prop_1 ) until forever ( prop_2 )
pred ltl: finally ( prop_1 until globally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or always ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , whenever ( prop_1 ) then all of the following conditions are true : the transition action that ( prop_2 ) must promptly happen , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: at some time ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( finally ( prop_1 ) and finally prop_2 )
gold: repeatedly ( prop_1 ) and whenever ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: whenever ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally [13,31] prop_3 )
gold: In the case ( prop_1 ) and ( prop_2 ) , then in response there has to exist a time within 13 to 31 time units , at which the scenario that ( prop_3 ) has to happen finally .
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally [13,31] prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Globally , if the scenario that ( prop_1 ) occurs then in response ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( ( ( prop_1 or prop_2 ) or prop_4 ) equal prop_3 )
gold: If either ( prop_1 ) or ( prop_2 ) or ( prop_4 ) is detected, then it is equivalent to have ( prop_3 ) .
pred ltl: ( ( ( prop_1 or prop_2 ) or prop_4 ) equal prop_3 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or globally prop_2 )
gold: whenever ( prop_1 ) or always ( prop_2 )
pred ltl: finally ( prop_1 or globally prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: ( ( ( prop_1 imply prop_3 ) or prop_4 ) equal prop_2 )
gold: It is equivalent to have the scenario that ( prop_2 ) if and only if either of the following two conditions is true : the scenario that ( prop_1 ) should lead to ( prop_3 ) , or the scenario that ( prop_4 ) .
pred ltl: ( ( ( prop_1 imply prop_3 ) or prop_4 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: whenever ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: ( prop_1 and globally prop_2 )
gold: ( prop_1 ) and forever ( prop_2 )
pred ltl: ( prop_1 and globally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )
gold: never ( prop_1 ) and never ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( ( ( prop_4 imply prop_1 ) or prop_2 ) until [487,667] prop_3 )
gold: It is required that until a certain time point within the first 487 to 667 time units either the scenario that ( prop_4 ) should happen must eventually lead to the scenario that ( prop_1 ) , or else ( prop_2 ) should be observed , and after this ( prop_3 ) .
pred ltl: ( ( ( prop_4 imply prop_1 ) or prop_2 ) until [487,667] prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or globally prop_2 )
gold: when possible ( prop_1 ) or always ( prop_2 )
pred ltl: finally ( prop_1 or globally prop_2 )

ltl: ( ( finally [72,468] prop_1 and prop_2 ) or prop_3 )
gold: There will be a certain moment within the next 72 to 468 time units , at which the scenario that ( prop_1 ) and ( prop_2 ) should be observed , or else ( prop_3 ) is true .
pred ltl: ( finally [72,468] ( prop_1 and prop_2 ) or prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that whenever the event that ( prop_1 ) is detected then all of the following conditions hold : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , when ( prop_1 ) then the following condition is true : ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( ( prop_3 and prop_1 ) imply prop_2 )
gold: If ( prop_3 ) and ( prop_1 ) then ( prop_2 ) .
pred ltl: ( ( prop_3 and prop_1 ) imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , in case that the transition action that ( prop_1 ) gets observed then all of the following conditions hold : the scenario that ( prop_2 ) and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( ( ( prop_4 until prop_1 ) equal prop_2 ) and prop_3 )
gold: If at some point ( prop_4 ) happens and continues to happen until ( prop_1 ) is detected , then the scenario is equivalent to ( prop_2 ) , and ( prop_3 ) .
pred ltl: ( ( ( prop_4 until prop_1 ) equal prop_2 ) and prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 and finally prop_2 )
gold: always ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: globally ( finally ( prop_1 ) until finally prop_2 )
gold: repeatedly ( prop_1 ) until at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: when ( prop_1 ) , ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: if whenever ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: negation ( finally ( prop_1 ) and finally prop_2 )
gold: don't ( prop_1 ) and when possible ( prop_2 )
pred ltl: negation ( finally ( prop_1 ) and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that when the event that ( prop_1 ) is detected then the following condition is true : ( prop_2 ) and the scenario that ( prop_3 ) will have to take place instantly .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( ( ( prop_1 equal prop_4 ) and prop_3 ) until prop_2 )
gold: The scenario in which either ( prop_1 ) is equivalent to ( prop_4 ), and ( prop_3 ) should always be true , until the scenario in which ( prop_2 ) .
pred ltl: ( ( ( prop_1 equal prop_4 ) and prop_3 ) until prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: In the case ( prop_1 ) , or ( prop_2 ) then ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 and finally prop_2 )
gold: forever ( prop_1 ) and at some time ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when when possible ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) can infer that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or forever ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , during the interval that ( prop_1 ) , and ( prop_2 ) then the following condition holds : at the same moment ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Globally , in case that ( prop_1 ) then all of the following conditions are true : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: negation ( prop_1 and finally prop_2 )
gold: do not ( prop_1 ) and at some time ( prop_2 )
pred ltl: negation ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , when ( prop_1 ) and ( prop_2 ) , then all of the following conditions hold : ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )
gold: It is always the case that if ( prop_1 ) , or the event that ( prop_2 ) does n't take place , then at the same time ( prop_3 ) , and right away the event that ( prop_4 ) must be observed .
pred ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and globally ( finally prop_2 ) )
gold: ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: ( prop_1 and globally ( finally prop_2 ) )

ltl: ( prop_1 and negation prop_2 )
gold: ( prop_1 ) and do not ( prop_2 )
pred ltl: ( prop_1 and negation prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [52,68] prop_2 ) )
gold: There exists a certain time point in the next 52 to 68 time units during the interval ( prop_1 ) at which ( prop_2 ) happens before ( prop_3 ).
pred ltl: globally ( prop_1 imply ( prop_3 until [52,68] prop_2 ) )

ltl: finally ( prop_2 and finally prop_3 )
gold: when possible ( prop_1 ) ( prop_2 ) and at some time ( prop_3 )
pred ltl: finally ( prop_2 and finally prop_3 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at any time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: When the transition action that ( prop_1 ) takes place , then the following condition holds : ( prop_2 ) , or the scenario that ( prop_3 ) needs to get observed at the same time .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when at any time ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: negation ( prop_1 or finally prop_2 )
gold: do not ( prop_1 ) or whenever ( prop_2 )
pred ltl: negation ( prop_1 or finally prop_2 )

ltl: ( ( prop_3 imply prop_1 ) imply prop_2 )
gold: If it is the case that the scenario in which ( prop_3 ) is detected then as a response ( prop_1 ) should happen , then ( prop_2 ) .
pred ltl: ( ( prop_3 imply prop_1 ) imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: In the case ( prop_1 ) , then all of the following conditions hold : without any delay ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( finally ( prop_1 ) imply globally ( finally prop_2 ) )
gold: if at some time ( prop_1 ) , repeatedly ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( finally prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or globally ( finally prop_2 ) )
gold: never ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or globally ( finally prop_2 ) )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: As soon as ( prop_1 ) then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( ( ( prop_4 until prop_1 ) imply prop_3 ) or prop_2 )
gold: ( prop_4 ) keeps happening until the scenario that ( prop_1 ) happens at some point in the future , then ( prop_3 ) should be observed , or else ( prop_2 ) .
pred ltl: ( ( ( prop_4 until prop_1 ) until prop_3 ) or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) can infer that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , during the interval that ( prop_1 ) , and ( prop_2 ) then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or globally ( negation prop_2 ) )
gold: never ( prop_1 ) or never ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or globally ( negation prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: if whenever ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 until [19,21] prop_4 ) )
gold: If ( prop_1 ) and ( prop_2 ) happen, then ( prop_3 ) will happen and continue until subsequently sometime between 19 to 21 units ( prop_4 ) happens.
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_4 until [19,21] prop_3 ) )

ltl: ( globally ( negation prop_1 ) imply prop_2 )
gold: never ( prop_1 ) means that ( prop_2 )
pred ltl: ( globally ( negation prop_1 ) imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: On condition that the event that ( prop_1 ) takes place , then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Everytime when the event that ( prop_1 ) takes place or ( prop_2 ) , then at once ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 or prop_4 ) )
gold: Whenever ( prop_1 ) , and the scenario that ( prop_2 ) is detected then in no time ( prop_3 ) or ( prop_4 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 or prop_4 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( negation ( prop_1 ) or globally prop_2 )
gold: never ( prop_1 ) or forever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or globally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( ( globally [285,337] prop_3 imply prop_2 ) equal prop_1 )
gold: It is necessary that if ( prop_3 ) is globally true at any time during the next 285 to 337 time units then in response ( prop_2 ) should happen , if and only if ( prop_1 ) is true .
pred ltl: ( globally [285,337] ( prop_3 imply prop_2 ) equal prop_1 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and globally prop_2 )
gold: at some time ( prop_1 ) and always ( prop_2 )
pred ltl: finally ( prop_1 and globally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: at any time ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , when ( prop_1 ) and ( prop_2 ) , then in response at the same time instant ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( globally ( finally ( prop_1 ) ) imply finally prop_2 )
gold: repeatedly ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( globally ( finally ( prop_1 ) ) imply finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally [14,19] prop_3 )
gold: When ( prop_1 ) and ( prop_2 ) happen, the scenario ( prop_3 ) will be detected within the following 14 to 19 time units.
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally [14,19] prop_3 )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: ( ( ( prop_1 equal prop_4 ) until prop_3 ) or prop_2 )
gold: It is required that either ( prop_1 ) is equivalent to ( prop_4 ) keeps true until ( prop_3 ) , or else ( prop_2 ) .
pred ltl: ( ( ( prop_1 equal prop_4 ) until prop_3 ) or prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: Globally , whenever the transition action that ( prop_1 ) is observed then all of the following conditions are true : in no time the transition action that ( prop_2 ) will have to happen or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) means that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: whenever ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or forever ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally ( finally prop_3 ) )
gold: It is always the case that everytime when ( prop_1 ) , and ( prop_2 ) , then all of the following conditions are true : for each moment in the future until the simulation ends at a certain time point within the next 1 to 29 time units , ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [1,29] ( finally prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( globally [114,336] ( prop_3 and prop_1 ) and prop_2 )
gold: For every moment in the next 114 to 336 time units while the scenario that ( prop_3 ) and ( prop_1 ) is detected , and ( prop_2 ) should also be observed .
pred ltl: ( globally [112,336] ( prop_3 and prop_1 ) and prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: Every time the transition action ( prop_1 ) happens, then in response ( prop_2 ) or right away the transition action ( prop_3 ) is detected.
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 imply globally ( negation prop_2 ) )
gold: when ( prop_1 ) , never ( prop_2 )
pred ltl: ( prop_1 imply globally ( negation prop_2 ) )

ltl: ( ( ( prop_3 or prop_1 ) equal prop_4 ) imply prop_2 )
gold: If it is the case that either ( prop_3 ) or ( prop_1 ) is satisfied if and only if ( prop_4 ) is satisfied then ( prop_2 ) is also satisfied .
pred ltl: ( ( ( prop_3 or prop_1 ) equal prop_4 ) imply prop_2 )

ltl: ( negation ( prop_3 and prop_2 ) or prop_1 )
gold: It is not the case that ( prop_3 ) and ( prop_2 ) , or ( prop_1 ) .
pred ltl: ( negation ( prop_3 and prop_2 ) or prop_1 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally prop_3 )
gold: On condition that ( prop_1 ) or the scenario that ( prop_2 ) takes place then all of the following conditions hold : ( prop_3 ) and consistently this scenario ought to keep in the future .
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally prop_3 )

ltl: ( ( ( prop_1 equal prop_2 ) or prop_3 ) and prop_4 )
gold: If ( prop_1 ) is equivalent to ( prop_2 ) or else ( prop_3 ) and also ( prop_4 ) .
pred ltl: ( ( ( prop_1 equal prop_2 ) or prop_3 ) and prop_4 )

ltl: negation ( finally [300,344] ( ( prop_2 imply prop_3 ) and prop_1 ) )
gold: It is not the case that at some point during the 300 to 344 time units finally that ( prop_2 ) implies that ( prop_3 ) and ( prop_1 ) .
pred ltl: ( negation ( finally [300,344] prop_2 imply prop_3 ) and prop_1 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or globally ( finally prop_2 ) )
gold: ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Whenever the scenario ( prop_1 ) is observed, the following conditions are true: ( prop_2 ) and ( prop_3 ).
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 and globally ( negation prop_2 ) )
gold: ( prop_1 ) and never ( prop_2 )
pred ltl: ( prop_1 and globally ( negation prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply finally [25,82] prop_3 )
gold: The scenario ( prop_3 ) will have to take place at some point within the 25 to 82 time units after either ( prop_1 ) or ( prop_2 ) happens.
pred ltl: globally ( ( prop_1 or prop_2 ) imply finally [25,82] prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: If the scenario ( prop_1 ) occurs, then ( prop_2 ) will happen.
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or globally ( finally prop_2 ) )
gold: ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: ( prop_1 or globally ( finally prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , if the scenario that ( prop_1 ) happens then the following condition holds : ( prop_2 ) , and at once ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) can infer that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and globally prop_2 )
gold: when possible ( prop_1 ) and always ( prop_2 )
pred ltl: finally ( prop_1 and globally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: if when possible ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: globally ( prop_1 imply ( prop_2 until [31,97] prop_2 ) )
gold: In the case ( prop_1 ) , then finally at sometime in the first 31 to 97 time units ( prop_2 ) .
pred ltl: globally ( prop_1 imply finally [31,97] prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: always ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 and prop_2 )
gold: forever ( prop_1 ) and ( prop_2 )
pred ltl: globally ( prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( ( negation prop_2 or prop_1 ) or prop_3 )
gold: Either it is not the case that ( prop_2 ) or else ( prop_1 ) , or else ( prop_3 ) .
pred ltl: ( negation ( prop_2 or prop_1 ) or prop_3 )

ltl: finally ( prop_1 until prop_2 )
gold: at some time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: whenever ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: It is always the case that if ( prop_1 ) then all of the following conditions are true : in no time ( prop_2 ) , or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( ( ( prop_1 until prop_2 ) and prop_4 ) and prop_3 )
gold: If ( prop_1 ) happens and continues to happen until ( prop_2 ) is detected , and also ( prop_4 ) , and ( prop_3 ) .
pred ltl: ( ( ( prop_1 until prop_2 ) and prop_4 ) and prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at some time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( ( ( prop_4 until [325,722] prop_3 ) equal prop_2 ) or prop_1 )
gold: In case that ( prop_4 ) happens and continues to happen until at some point during the 325 to 722 time units ( prop_3 ) is detected , this is equivalent to the scenario in which ( prop_2 ) happens , or else ( prop_1 ) .
pred ltl: ( ( ( prop_4 until [325,722] prop_3 ) equal prop_2 ) or prop_1 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 or prop_4 ) )
gold: Globally , whenever the scenario that ( prop_1 ) is observed or ( prop_2 ) then all of the following conditions are true : ( prop_3 ) or simultaneously ( prop_4 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 or prop_4 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( finally prop_1 and prop_2 )
gold: repeatedly ( prop_1 ) and ( prop_2 )
pred ltl: globally ( finally prop_1 and prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when at any time ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at any time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: finally ( prop_1 or globally prop_2 )
gold: when possible ( prop_1 ) or forever ( prop_2 )
pred ltl: finally ( prop_1 or globally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at any time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( globally ( prop_1 ) imply finally prop_2 )
gold: when forever ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( globally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: negation ( finally ( prop_1 ) or finally prop_2 )
gold: do not ( prop_1 ) or whenever ( prop_2 )
pred ltl: negation ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) and repeatedly ( prop_2 )
pred ltl: finally ( prop_1 and globally ( finally prop_2 ) )

ltl: globally ( prop_1 and finally prop_2 )
gold: forever ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that if ( prop_1 ) , then all of the following conditions are true : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: negation ( finally ( prop_1 ) or finally prop_2 )
gold: don't ( prop_1 ) or at some time ( prop_2 )
pred ltl: negation ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( ( negation prop_3 and prop_1 ) until [394,612] prop_2 )
gold: ( prop_3 ) does not happen and ( prop_1 ) happens , and this scenario will hold until at some other point during the 394 to 612 time units ( prop_2 ) is detected .
pred ltl: ( ( negation prop_3 and prop_1 ) until [394,612] prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( prop_1 until finally prop_2 )
gold: always ( prop_1 ) until when possible ( prop_2 )
pred ltl: globally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: when ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when at any time ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( negation prop_1 until prop_2 )
gold: never ( prop_1 ) until ( prop_2 )
pred ltl: globally ( negation prop_1 until prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally [8,9] prop_3 )
gold: There needs to be an event ( prop_3 ) that happens within 8 to 9 time units every time ( prop_1 ) and ( prop_2 ) happen.
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally [8,9] prop_3 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally prop_3 )
gold: It is always the case that when ( prop_1 ) , and ( prop_2 ) , then all of the following conditions hold : there should exist sometime in the future before the simulation ends , at which ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and negation ( finally prop_2 ) )
gold: at any time ( prop_1 ) and don't ( prop_2 )
pred ltl: finally ( prop_1 and negation prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( globally ( finally ( prop_1 ) ) imply finally prop_2 )
gold: repeatedly ( prop_1 ) can infer that whenever ( prop_2 )
pred ltl: ( globally ( finally ( prop_1 ) ) imply finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , during the interval that the transition action that ( prop_1 ) is not detected or ( prop_2 ) then all of the following conditions hold : promptly ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) until never ( prop_2 )
pred ltl: finally ( prop_1 until globally ( negation prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: whenever ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( negation prop_1 or prop_2 )
gold: never ( prop_1 ) or ( prop_2 )
pred ltl: globally ( negation prop_1 or prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [1,22] ( finally [77,83] prop_3 ) )
gold: In case that the event that ( prop_1 ) occurs , and ( prop_2 ) then the following condition holds : for each time point in the first 1 to 22 time units , there will have to be sometime within the next 77 to 83 time units , at which ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [1,22] ( finally [77,83] prop_3 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) means that at any time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: always ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and globally ( negation prop_2 ) )
gold: ( prop_1 ) and never ( prop_2 )
pred ltl: ( prop_1 and globally ( negation prop_2 ) )

ltl: ( prop_1 or negation prop_2 )
gold: ( prop_1 ) or do not ( prop_2 )
pred ltl: ( prop_1 or negation prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) means that whenever ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: If ( prop_1 ) , then all of the following conditions are true : promptly ( prop_2 ) , and the event that ( prop_3 ) is promptly observed .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )
gold: In the case ( prop_1 ) , or ( prop_2 ) then in response ( prop_3 ) , and the transition action that ( prop_4 ) must be observed at the same time instant .
pred ltl: globally ( ( prop_1 or prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: globally ( prop_1 imply prop_2 )
gold: In the event that ( prop_1 ) then the following condition holds : immediately ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) can infer that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )
gold: Globally , when ( prop_1 ) , and the event that ( prop_2 ) happens then ( prop_3 ) , and the event that ( prop_4 ) takes place at once .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: ( prop_1 imply finally prop_2 )
gold: when ( prop_1 ) , at any time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: negation ( prop_1 or negation prop_2 )
gold: do not ( prop_1 ) or do not ( prop_2 )
pred ltl: negation ( prop_1 or negation prop_2 )

ltl: ( negation ( prop_1 imply prop_3 ) imply prop_2 )
gold: If it is not the case that ( prop_1 ) then ( prop_3 ) , then ( prop_2 ) .
pred ltl: ( negation ( prop_1 imply prop_3 ) imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_3 imply prop_1 ) until [446,604] prop_2 ) and prop_4 )
gold: If ( prop_3 ) then ( prop_1 ) happens and this scenario will hold until at some other point during the 446 to 604 time units ( prop_2 ) is detected , and ( prop_4 ) .
pred ltl: ( ( ( prop_3 imply prop_1 ) until [446,604] prop_2 ) and prop_4 )

ltl: ( ( negation prop_1 and prop_2 ) equal prop_3 )
gold: The scenario in which ( prop_1 ) does not happen and ( prop_2 ) does is equivalent to the scenario in which ( prop_3 ) happens .
pred ltl: ( ( negation prop_1 and prop_2 ) equal prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at some time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( ( ( prop_1 or prop_4 ) equal prop_2 ) until [270,503] prop_3 )
gold: If at some point ( prop_1 ) or ( prop_4 ) is equivalent to ( prop_2 ) then this scenario will hold until at some other point during the 270 to 503 time units ( prop_3 ) is detected .
pred ltl: ( ( ( prop_1 or prop_4 ) equal prop_2 ) until [270,503] prop_3 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that when the event that ( prop_1 ) occurs , then ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( ( prop_1 equal prop_2 ) imply prop_3 )
gold: ( prop_1 ) if and only if ( prop_2 ) then this implies ( prop_3 ) .
pred ltl: ( ( prop_1 equal prop_2 ) imply prop_3 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at some time ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Everytime when the scenario that ( prop_1 ) happens then the following condition is true : starting without any delay ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [63,75] prop_2 ) )
gold: The scenario ( prop_1 ) must be observed in order to respond to it. There must be a time frame of 63 to 75 time units in order to ultimately observe ( prop_2 ) , and ( prop_3 ) must happen before that.
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that whenever the transition action that ( prop_1 ) gets observed , then in response ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: In the case the scenario that ( prop_1 ) is observed , then ( prop_2 ) and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( ( ( prop_2 imply prop_4 ) until prop_1 ) imply prop_3 )
gold: It should be the case that ( prop_2 ) leads to ( prop_4 ) until ( prop_1 ) happens , then implying that ( prop_3 ) is also true .
pred ltl: ( ( ( prop_2 imply prop_4 ) until prop_1 ) imply prop_3 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: if ( prop_1 ) , when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until at any time ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply globally [0,5] ( finally [0,48] prop_3 ) )
gold: It is always the case that everytime when the event that ( prop_1 ) gets observed , or ( prop_2 ) then for every moment during the following 0 to 5 time units the transition action that ( prop_3 ) needs to be finally observed at a time in less than 48 time units .
pred ltl: globally ( ( prop_1 or prop_2 ) imply globally [0,5] ( finally [48] prop_3 ) )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that at some time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at some time ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 imply ( prop_3 until [14,18] prop_2 ) )
gold: Whenever the transition action ( prop_1 ) is observed, there should be a certain time instant during the next 14 to 18 time units at which ( prop_2 ) happens, before ( prop_3 ).
pred ltl: globally ( prop_1 imply ( prop_3 until [14,18] prop_2 ) )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( ( ( prop_1 equal prop_3 ) until prop_4 ) imply prop_2 )
gold: If ( prop_1 ) is equivalent to ( prop_3 ) and this scenario continues until ( prop_4 ) is detected , then ( prop_2 ) .
pred ltl: ( ( ( prop_1 equal prop_3 ) until prop_4 ) imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( negation prop_1 or prop_2 )
gold: never ( prop_1 ) or ( prop_2 )
pred ltl: globally ( negation prop_1 or prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )
gold: It is always the case that while ( prop_1 ) and ( prop_2 ) , then all of the following conditions are true : at the same moment ( prop_3 ) and promptly ( prop_4 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_3 and prop_4 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: negation ( finally ( prop_1 ) and finally prop_2 )
gold: don't ( prop_1 ) and at any time ( prop_2 )
pred ltl: negation ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: As soon as ( prop_1 ) , then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( ( prop_1 or prop_3 ) and prop_2 )
gold: ( prop_1 ) or ( prop_3 ) , and ( prop_2 ) .
pred ltl: ( ( prop_1 or prop_3 ) and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 until negation prop_2 )
gold: forever ( prop_1 ) until do not ( prop_2 )
pred ltl: globally ( prop_1 until negation prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: If the event ( prop_1 ) is detected, then the event ( prop_2 ) should occur at the same time ( prop_3 ).
pred ltl: globally ( prop_1 imply ( prop_2 until prop_3 ) )

ltl: ( finally ( prop_3 and prop_2 ) and prop_1 )
gold: It is required that at the end of the simulation , ( prop_3 ) and ( prop_2 ) , and ( prop_1 ) should also happen .
pred ltl: ( ( ( prop_3 and prop_2 ) and prop_1 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( prop_1 or globally ( negation prop_2 ) )
gold: ( prop_1 ) or never ( prop_2 )
pred ltl: ( prop_1 or globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , while ( prop_1 ) and ( prop_2 ) then the following condition is true : at once ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when when possible ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Globally , everytime when ( prop_1 ) , then ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 and finally prop_2 )
gold: forever ( prop_1 ) and whenever ( prop_2 )
pred ltl: globally ( prop_1 and finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) can infer that whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , in case that ( prop_1 ) then without any delay ( prop_2 ) , and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( ( ( prop_3 equal prop_1 ) until prop_2 ) imply prop_4 )
gold: If at some point ( prop_3 ) is equivalent to ( prop_1 ) and this scenario continues to hold until ( prop_2 ) is detected , then ( prop_4 ) .
pred ltl: ( ( ( prop_3 equal prop_1 ) until prop_2 ) imply prop_4 )

ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )
gold: if whenever ( prop_1 ) , never ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: It is always the case that when ( prop_1 ) and the event ( prop_2 ) is observed, then all of the following conditions are true: ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( globally ( prop_1 ) imply finally prop_2 )
gold: always ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( globally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: As soon as ( prop_1 ) , and the scenario that ( prop_2 ) occurs then all of the following conditions are true : at the same time point ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or forever ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )
gold: never ( prop_1 ) and never ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and globally ( negation prop_2 ) )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , when ( prop_1 ) and ( prop_2 ) then in response at the same moment ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when possible ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_2 until finally prop_3 )
gold: at some time ( prop_1 ) ( prop_2 ) until when possible ( prop_3 )
pred ltl: finally ( prop_2 until finally prop_3 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Whenever ( prop_1 ) happens, then ( prop_2 ) and ( prop_3 ) will happen.
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , in case that the scenario that ( prop_1 ) does n't happen , and ( prop_2 ) , then all of the following conditions hold : at the same moment ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally prop_2 )
gold: ( prop_1 ) or forever ( prop_2 )
pred ltl: ( prop_1 or globally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply globally [22,61] ( finally [0,24] prop_3 ) )
gold: Globally , when ( prop_1 ) and ( prop_2 ) , then the following condition holds : for every moment in the subsequent 22 to 61 time units , there should be sometime in the coming 0 to 24 time units , at which the event that ( prop_3 ) should not take place eventually .
pred ltl: globally ( ( prop_1 and prop_2 ) imply globally [22,61] ( finally [0,24] prop_3 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: when at any time ( prop_1 ) , ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( negation ( prop_1 equal prop_2 ) until [394,530] prop_3 )
gold: It is not the case that ( prop_1 ) if and only if ( prop_2 ) is true , the above scenario will hold until ( prop_3 ) will be detected at some time point during the next 394 to 530 time units .
pred ltl: ( negation ( prop_1 equal prop_2 ) until [394,530] prop_3 )

ltl: finally ( prop_1 until globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) until never ( prop_2 )
pred ltl: finally ( prop_1 until globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply prop_2 )
gold: Whenever the scenario that ( prop_1 ) gets detected , then all of the following conditions hold : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( finally ( prop_3 imply prop_2 ) or prop_1 )
gold: At some point during the coming time units ( prop_3 ) should happen and then ( prop_2 ) , or else ( prop_1 ) .
pred ltl: ( finally ( prop_3 imply prop_2 ) or prop_1 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( globally ( negation prop_1 ) imply prop_2 )
gold: if never ( prop_1 ) , ( prop_2 )
pred ltl: ( globally ( negation prop_1 ) imply prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: It is always the case that everytime when ( prop_1 ) or ( prop_2 ) then in response in no time ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( prop_1 until prop_2 )
gold: always ( prop_1 ) until ( prop_2 )
pred ltl: globally ( prop_1 until prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or when possible ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 until globally ( negation prop_2 ) )
gold: ( prop_1 ) until never ( prop_2 )
pred ltl: ( prop_1 until globally ( negation prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: at any time ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: In case that the scenario that ( prop_1 ) is detected then all of the following conditions are true : the scenario that ( prop_2 ) needs to be detected starting without any delay or immediately ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply finally [25,33] ( globally [5,89] prop_3 ) )
gold: Whenever the event ( prop_1 ) gets detected and ( prop_2 ) then ( prop_3 ) will happen within the next 25 to 33 time units. This scenario must hold for every time point during the coming 5 to 89 time units.
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally [25,33] ( globally [5,89] prop_3 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: As soon as ( prop_1 ) , or the transition action that ( prop_2 ) happens , then all of the following conditions hold : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: As soon as the scenario that ( prop_1 ) happens , then the following condition holds : simultaneously ( prop_2 ) , or starting without any delay ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply prop_2 )
gold: As soon as ( prop_1 ) then the following condition is true : at the same time ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: globally ( negation ( prop_1 ) or finally prop_2 )
gold: never ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at any time ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: globally ( prop_1 and prop_2 )
gold: forever ( prop_1 ) and ( prop_2 )
pred ltl: globally ( prop_1 and prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , in case that the event that ( prop_1 ) gets observed or ( prop_2 ) , then all of the following conditions are true : instantly ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( ( ( prop_4 equal prop_2 ) or prop_3 ) or prop_1 )
gold: The scenario that ( prop_4 ) is detected if and only if the scenario that ( prop_2 ) is detected , or the scenario that ( prop_3 ) is detected , or the scenario that ( prop_1 ) is detected .
pred ltl: ( ( ( prop_4 equal prop_2 ) or prop_3 ) or prop_1 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) until finally prop_2 )
gold: never ( prop_1 ) until at some time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) until finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until when possible ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( negation ( prop_3 equal prop_1 ) and prop_2 )
gold: ( prop_3 ) is not equivalent to ( prop_1 ) , and ( prop_2 ) .
pred ltl: ( ( negation prop_3 equal prop_1 ) and prop_2 )

ltl: globally ( finally prop_1 or prop_2 )
gold: repeatedly ( prop_1 ) or ( prop_2 )
pred ltl: globally ( finally prop_1 or prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if whenever ( prop_1 ) , at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: It is always the case that whenever ( prop_1 ) , and ( prop_2 ) then at the same time ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )
gold: when possible ( prop_1 ) can infer that never ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply globally ( negation prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: Whenever the scenario that ( prop_1 ) occurs , then starting without any delay the scenario that ( prop_2 ) will be detected or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( globally ( prop_2 imply prop_1 ) equal prop_3 )
gold: It is true that if the scenario that ( prop_2 ) is detected then ( prop_1 ) should happen if and only if the scenario that ( prop_3 ) is detected .
pred ltl: ( ( prop_2 imply prop_1 ) equal prop_3 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or at some time ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( globally ( finally prop_1 ) imply prop_2 )
gold: if repeatedly ( prop_1 ) , ( prop_2 )
pred ltl: ( globally ( finally prop_1 ) imply prop_2 )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( prop_1 until prop_2 )
gold: ( prop_1 ) until ( prop_2 )
pred ltl: ( prop_1 until prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that at some time ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: negation ( prop_1 and finally prop_2 )
gold: do not ( prop_1 ) and at any time ( prop_2 )
pred ltl: negation ( finally ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 until finally prop_2 )
gold: always ( prop_1 ) until when possible ( prop_2 )
pred ltl: globally ( prop_1 until finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: If the event that ( prop_1 ) gets observed then the following condition is true : at the same time ( prop_2 ) , or in no time ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: globally ( negation ( prop_1 ) or negation prop_2 )
gold: never ( prop_1 ) or don't ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) or negation ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: whenever ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if at any time ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_3 or prop_1 ) equal prop_4 ) or prop_2 )
gold: It is true that ( prop_3 ) or ( prop_1 ) is equivalent to ( prop_4 ) , or ( prop_2 ) .
pred ltl: ( ( ( prop_3 or prop_1 ) equal prop_4 ) or prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: always ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) and never ( prop_2 )
pred ltl: finally ( prop_1 and globally ( negation prop_2 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: if whenever ( prop_1 ) , whenever ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: whenever ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and whenever ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: negation ( prop_1 until prop_2 )
gold: don't ( prop_1 ) until ( prop_2 )
pred ltl: negation ( prop_1 until prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or globally ( finally prop_2 ) )
gold: when possible ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: finally ( prop_1 or globally ( finally prop_2 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: whenever ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( negation prop_1 and prop_2 )
gold: never ( prop_1 ) and ( prop_2 )
pred ltl: globally ( negation prop_1 and prop_2 )

ltl: finally ( prop_1 or globally ( negation prop_2 ) )
gold: at some time ( prop_1 ) or never ( prop_2 )
pred ltl: finally ( prop_1 or globally ( negation prop_2 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: when possible ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: When the scenario ( prop_1 ) is detected, then ( prop_2 ) and ( prop_3 ) will both be true.
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: finally ( prop_2 or finally prop_3 )
gold: when possible ( prop_1 ) ( prop_2 ) or at any time ( prop_3 )
pred ltl: finally ( prop_2 or finally prop_3 )

ltl: ( ( negation prop_2 equal prop_1 ) and prop_3 )
gold: ( prop_2 ) is not true if and only if  ( prop_1 ) , and also ( prop_3 ) should be true .
pred ltl: ( ( negation prop_2 equal prop_1 ) and prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: It is always the case that whenever ( prop_1 ) , or ( prop_2 ) then all of the following conditions are true : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , while ( prop_1 ) or ( prop_2 ) , then all of the following conditions hold : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: when possible ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or when possible ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at any time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: In case that the scenario that ( prop_1 ) is observed then in response the event that ( prop_2 ) ought to get detected without any delay , or ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( finally prop_1 imply prop_2 )
gold: at any time ( prop_1 ) means that ( prop_2 )
pred ltl: ( finally prop_1 imply prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: at some time ( prop_1 ) until when possible ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 and prop_2 )
gold: forever ( prop_1 ) and ( prop_2 )
pred ltl: globally ( prop_1 and prop_2 )

ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )
gold: It is always the case that when the scenario that ( prop_1 ) is observed then all of the following conditions hold : at the same time ( prop_2 ) , or in no time ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 or prop_3 ) )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: whenever ( prop_1 ) can infer that when possible ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that everytime when the transition action that ( prop_1 ) takes place then all of the following conditions hold : immediately ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and negation prop_2 )
gold: when possible ( prop_1 ) and don't ( prop_2 )
pred ltl: finally ( prop_1 and negation prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: ( prop_n )

It is always the case that when either ( prop_1 ) or ( prop_2 ) happens, then all of the following conditions will hold: ( prop_3 ) .. ( prop_n ).
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: It is always the case that whenever ( prop_1 ) then the following condition holds : the event that ( prop_2 ) must immediately take place and ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( globally [403,649] ( prop_1 or prop_2 ) and prop_3 )
gold: It is always the case that during the 403 to 649 time units either ( prop_1 ) or ( prop_2 ) , and in addition ( prop_3 ) is satisfied .
pred ltl: ( globally [403,649] ( prop_1 or prop_2 ) and prop_3 )

ltl: globally ( prop_1 imply ( prop_3 until [26,45] prop_2 ) )
gold: There should be a certain time within the next 26 to 45 time units at which ( prop_2 ) happens, before ( prop_3 ) continuously happens.
pred ltl: ( prop_3 until [26,45] prop_2 )

ltl: negation ( ( prop_3 until prop_2 ) and prop_1 )
gold: It is not the case that ( prop_3 ) continues to happen until at some point ( prop_2 ) happens and also ( prop_1 ) .
pred ltl: ( negation ( prop_3 until prop_2 ) and prop_1 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( finally ( prop_1 ) imply finally prop_2 )
gold: at any time ( prop_1 ) means that at some time ( prop_2 )
pred ltl: ( finally ( prop_1 ) imply finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply finally prop_2 )
gold: ( prop_1 ) means that when possible ( prop_2 )
pred ltl: ( prop_1 imply finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 until prop_3 ) )
gold: It is always the case that if ( prop_1 ) , then the following condition holds : ( prop_2 ) and then should continue like this consecutively until ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 until prop_3 ) )

ltl: negation ( ( prop_1 equal prop_3 ) until [43,346] prop_2 )
gold: It is not the case that ( prop_1 ) is equivalent to ( prop_3 ) and this scenario will hold until at some point during the 43 to 346 time units ( prop_2 ) is detected .
pred ltl: ( negation ( prop_1 equal prop_3 ) until [43,346] prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: It is always the case that if ( prop_1 ) and ( prop_2 ) then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until at some time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: at any time ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) can infer that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: In the event that ( prop_1 ) and ( prop_2 ) , then the following condition holds : ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( ( ( prop_2 and prop_4 ) until prop_3 ) and prop_1 )
gold: In case that ( prop_2 ) and ( prop_4 ) happens and continues to happen until ( prop_3 ) is detected , and ( prop_1 ) .
pred ltl: ( ( ( prop_2 and prop_4 ) until prop_3 ) and prop_1 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: Globally , whenever ( prop_1 ) , or the event that ( prop_2 ) takes place then all of the following conditions hold : right away ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( prop_1 or globally ( finally prop_2 ) )
gold: always ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: globally ( prop_1 or globally ( finally prop_2 ) )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: In case that the event that ( prop_1 ) happens then the following condition is true : the transition action that ( prop_2 ) must take place in no time and at the same time ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: ( prop_1 and prop_2 )
gold: ( prop_1 ) and ( prop_2 )
pred ltl: ( prop_1 and prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: when possible ( prop_1 ) until at any time ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: ( prop_1 until finally prop_2 )
gold: ( prop_1 ) until whenever ( prop_2 )
pred ltl: ( prop_1 until finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_1 equal prop_3 ) until [85,154] prop_4 ) or prop_2 )
gold: If ( prop_1 ) is equivalent to ( prop_3 ) and this scenario continues to hold until at some point during the 85 to 154 time units ( prop_4 ) is detected , or else ( prop_2 ) .
pred ltl: ( ( ( prop_1 equal prop_3 ) until [85,154] prop_4 ) or prop_2 )

ltl: globally ( negation ( prop_1 ) until finally prop_2 )
gold: never ( prop_1 ) until at any time ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) until finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )
gold: Globally , if ( prop_1 ) , then all of the following conditions are true : immediately ( prop_2 ) , and promptly ( prop_3 ) .
pred ltl: globally ( prop_1 imply ( prop_2 and prop_3 ) )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: In the case the transition action that ( prop_1 ) does not take place or ( prop_2 ) then the following condition holds : ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )
gold: When ( prop_1 ) or ( prop_2 ) , then ( prop_3 ) .
pred ltl: globally ( ( prop_1 or prop_2 ) imply prop_3 )

ltl: finally ( prop_1 or prop_2 )
gold: whenever ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and when possible ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: when possible ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: when ( prop_1 ) , ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 or prop_2 )
gold: at some time ( prop_1 ) or ( prop_2 )
pred ltl: finally ( prop_1 or prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: Globally , when ( prop_1 ) , then the following condition holds : promptly ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: whenever ( prop_1 ) or whenever ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and whenever ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )
gold: In case that ( prop_1 ) , and ( prop_2 ) , then all of the following conditions hold : finally at a certain moment in the future before the simulation ends ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply finally ( globally prop_3 ) )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and at any time ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at some time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: ( prop_1 or globally ( finally prop_2 ) )
gold: ( prop_1 ) or repeatedly ( prop_2 )
pred ltl: ( prop_1 or globally ( finally prop_2 ) )

ltl: ( prop_1 and finally prop_2 )
gold: ( prop_1 ) and when possible ( prop_2 )
pred ltl: ( prop_1 and finally prop_2 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or at any time ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 until prop_2 )
gold: always ( prop_1 ) until ( prop_2 )
pred ltl: globally ( prop_1 until prop_2 )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Whenever ( prop_1 ) and ( prop_2 ) then ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: globally ( prop_1 imply prop_2 )
gold: If the scenario that ( prop_1 ) happens , then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: at any time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: ( negation ( prop_2 until prop_1 ) equal prop_3 )
gold: It is not the case that ( prop_2 ) happens sometime before and until ( prop_1 ) if and only if ( prop_3 ) .
pred ltl: ( negation ( prop_2 until prop_1 ) equal prop_3 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at some time ( prop_1 ) or at some time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( ( ( prop_3 imply prop_4 ) until [72,144] prop_1 ) and prop_2 )
gold: While ( prop_1 ) will happen in the next 72 to 144 time units or , at some point before that , it will have been the case that ( prop_3 ) implies ( prop_4 ), and in the meantime ( prop_2 ) will happen .
pred ltl: ( ( ( prop_1 or prop_3 ) imply prop_4 ) and prop_2 )

ltl: finally ( prop_1 until prop_2 )
gold: when possible ( prop_1 ) until ( prop_2 )
pred ltl: finally ( prop_1 until prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that everytime when the event that ( prop_1 ) is observed , then ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: globally ( prop_1 or finally prop_2 )
gold: forever ( prop_1 ) or whenever ( prop_2 )
pred ltl: globally ( prop_1 or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that when ( prop_1 ) , then the following condition holds : ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: finally ( prop_1 and prop_2 )
gold: when possible ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: globally ( finally ( prop_1 ) or finally prop_2 )
gold: repeatedly ( prop_1 ) or at any time ( prop_2 )
pred ltl: globally ( finally ( prop_1 ) or finally prop_2 )

ltl: globally ( prop_1 imply prop_2 )
gold: It is always the case that when the transition action that ( prop_1 ) takes place then all of the following conditions are true : at the same time ( prop_2 ) .
pred ltl: globally ( prop_1 imply prop_2 )

ltl: ( prop_1 until negation prop_2 )
gold: ( prop_1 ) until don't ( prop_2 )
pred ltl: ( prop_1 until negation ( finally prop_2 ) )

ltl: ( ( ( prop_2 imply prop_4 ) equal prop_1 ) imply prop_3 )
gold: If it is the case that ( prop_2 ) implies ( prop_4 ) is equivalent to ( prop_1 ), then implies ( prop_3 ) .
pred ltl: ( ( ( prop_2 imply prop_4 ) imply prop_1 ) imply prop_3 )

ltl: finally ( prop_1 and prop_2 )
gold: at some time ( prop_1 ) and ( prop_2 )
pred ltl: finally ( prop_1 and prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: when possible ( prop_1 ) or at any time ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: finally ( prop_1 or finally prop_2 )
gold: at any time ( prop_1 ) or when possible ( prop_2 )
pred ltl: finally ( prop_1 or finally prop_2 )

ltl: ( prop_1 imply prop_2 )
gold: ( prop_1 ) can infer that ( prop_2 )
pred ltl: ( prop_1 imply prop_2 )

ltl: globally ( prop_1 or prop_2 )
gold: always ( prop_1 ) or ( prop_2 )
pred ltl: globally ( prop_1 or prop_2 )

ltl: globally ( ( prop_1 or prop_2 ) imply finally ( globally prop_3 ) )
gold: The condition ( prop_3 ) will be true at some point in the future when either ( prop_1 ) or ( prop_2 ) is true.
pred ltl: globally ( ( prop_1 or prop_2 ) imply finally ( globally prop_3 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_4 until [4,49] prop_3 ) )
gold: It is always the case that when ( prop_1 ) and ( prop_2 ) are true, then ( prop_3 ) will be true at some point in the next 4 to 49 time units. Before that, ( prop_4 ) will be true.
pred ltl: globally ( ( prop_1 and prop_2 ) imply ( prop_4 until [4,49] prop_3 ) )

ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )
gold: Globally , whenever ( prop_1 ) and ( prop_2 ) then all of the following conditions hold : at the same moment ( prop_3 ) .
pred ltl: globally ( ( prop_1 and prop_2 ) imply prop_3 )

ltl: ( prop_1 or prop_2 )
gold: ( prop_1 ) or ( prop_2 )
pred ltl: ( prop_1 or prop_2 )

ltl: globally ( negation ( prop_1 ) and finally prop_2 )
gold: never ( prop_1 ) and when possible ( prop_2 )
pred ltl: globally ( negation ( prop_1 ) and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: when possible ( prop_1 ) and at some time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at any time ( prop_1 ) and whenever ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_1 until finally prop_2 )
gold: whenever ( prop_1 ) until whenever ( prop_2 )
pred ltl: finally ( prop_1 until finally prop_2 )

ltl: finally ( prop_1 and finally prop_2 )
gold: at some time ( prop_1 ) and at any time ( prop_2 )
pred ltl: finally ( prop_1 and finally prop_2 )

ltl: finally ( prop_2 or finally prop_3 )
gold: at any time ( prop_1 ) ( prop_2 ) or at any time ( prop_3 )
pred ltl: finally ( prop_2 or finally prop_3 )

ltl: ( prop_1 or finally prop_2 )
gold: ( prop_1 ) or whenever ( prop_2 )
pred ltl: ( prop_1 or finally prop_2 )

